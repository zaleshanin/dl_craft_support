.apply(function () {
    if(.tmp.craft==null) .tmp.craft = .Map();
    if(.tmp.craft.logging==null) .tmp.craft.logging = .Map();
    this = .tmp.craft.logging;

    //всякие переменные для скрипта:
    if(LoggingForestList==null) 
        LoggingForestList = .List(); //список для хранения комнат где велась лесозаготовка

    //TreeLog = .get_obj_index(28037); //бревно - результат рубки
    TreeLog = .get_obj_index(3377); //бревно - результат рубки
    MaxTreeHP = 100; 

    //топор, и его onUse, postUse
    var Axe; //просто переменная
    //Axe = .get_obj_index(6000); //присваиваем переменной ссылку на прототип топора
    Axe = .get_obj_index(3026); //присваиваем переменной ссылку на прототип топора
    Axe.onUse = function (axe, ch, str) {
        if(ch.start_logging!=null) ch.start_logging = null;

        //уже рубим - прекращаем
        if(ch.logging!=null) {ch.logging=null;return true;}

        //не в инвентаре
        //TODO - подымаем!!!
        if(axe.getCarrier()!=ch) {
            ch.act('Возможно %1$O4 следует поднять.', axe);
            ch.recho("%1$^C1 дотрагивается до %2$O2.", ch, axe);
            return true;
        }

        //не вооружен
        //TODO - вооружаемся
        if(axe.wear_loc!='wield') {
            ch.act('%1$^O5 следует вооружиться.', axe);
            return true;
        }

        //не лес
        if(ch.in_room.sector_type!=.tables.sector_table.forest) {
            ch.act('Здесь нечего рубить. Ты с сожалением вздыхаешь.');
            ch.recho("%1$^C1 с сожалением вздыхает держа в руках %2$O4.", ch, axe);
            return true;
        }
        
        //всё вырубили //TODO v2 убрать - оставить только проверку сектора.
        if(ch.in_room.logging!=null && ch.in_room.logging.trees_health<=0) {
            ch.act('Здесь нечего рубить - вокруг одни пеньги.');
            ch.recho("%1$^C1 с %2$O4 в руках оглядывет окружающие пеньки.", ch, axe);
            return true;           
        }

        //дерёшься
        if (ch.position&.tables.position_table.fight) {
            ch.act('Сейчас ты и так делаешь %1$^O5 всё что можешь.', axe);
            return true;
        }

         //не стоишь
        if (!(ch.position&.tables.position_table.stand)) {
            ch.act('Рубить деревья можно только твёрдо стоя на ногах.');
            return true;
        }

        ch.start_logging = true;

        return true;
    };
    Axe.postUse = function(axe, ch, str) {
        try{
            if(.tmp.craft.logging==null) {
                ch.act('Ты собирал%Gось|ся|ась срубить дерево, но что-то пошло не так.',ch);
                throw "logging: no .tmp.craft.logging";
            }
            this = .tmp.craft.logging;

            if(ch.start_logging==null) return;
            else ch.start_logging=null;

            //TODO проверяем/генерим деревца.
            if(ch.in_room.logging==null) {
                loggingForestRoomInit(ch.in_room);
            }

            //TODO и вдруг... ЭНТ!
            //TODO начинаем рубить
            ch.act('Начинаем производственную гимнастику!'); //TODO убрать
            ch.logging=true;
            /*var chopsCount; chopsCount = getChopsCount(ch);*/
            var sleepInterval; sleepInterval = getSleepInterval(ch);
            var current_tree_quantity;
            current_tree_quantity = (ch.in_room.logging.trees_health / MaxTreeHP);
            if(ch.in_room.logging.trees_health % MaxTreeHP > 0) 
                current_tree_quantity = current_tree_quantity + 1;
            
            if(.buildplot) 
                debug(.fmt("craft_logging: [%d:%s]status_before: max_hp->%d trees->%d hp->%d sprouts->%d",
                ch.in_room.vnum, ch.in_room.name, ch.in_room.logging.max_trees_health, current_tree_quantity, ch.in_room.logging.trees_health, ch.in_room.logging.sprouts_health));
            for( ; ch.in_room.logging.trees_health > (current_tree_quantity-1)*MaxTreeHP ; ) {
                sleepRoom(sleepInterval,ch,axe);

                makeOneHit(ch,axe);
                
                //TODO аффект когда всё вырублено (подробности в трелло-карточка рубки, феневый чат)
                //TODO v2 выгоднять из камуфляжа всех кто в комнате ))
            }
            if(.buildplot) 
                debug(.fmt("craft_logging: [%d:%s]status_after: max_hp->%d hp->%d sprouts->%d",
                ch.in_room.vnum, ch.in_room.name, ch.in_room.logging.max_trees_health, ch.in_room.logging.trees_health, ch.in_room.logging.sprouts_health));
            ch.act('Закончили упражнение!');//TODO убрать

            if(isLoggingSuccessful(ch)) {
                ch.in_room.echo('Дерево с грохотом падает, превращаясь в качественное бревно!');
                logToRoom(ch.in_room);
            } else {
                ch.in_room.echo('Изрубленное в капусту дерево, падая превращается в кучу бесполезных щепок!');
            }
        }catch(e){
            catchMsg(e);
        }
        ch.logging=null;
    };
    //чар снимает топор - прекращаем рубить дерево
    Axe.onRemove = function (axe, ch) {
        if(ch.logging!=null) {ch.logging=null;}
    };

    //Всякие вспомонательные функции:
    getSleepInterval = function(ch) {
        var result;
        result = 4;

        if(.buildplot) result=result/2;

        //TODO наличие хасты (result=result/2);

        //TODO наличие механика (result=result/2);

        return result;
    };

    isLoggingSuccessful = function(ch) {
        var limit;
        limit = 4;
        //TODO skill (limit=limit-2)
        //TODO mechanic  (limit=1)
        if(.buildplot) limit=2;
        if(.number_range(1,limit)!=1) return false;
        return true;
    };
    //делаем один удар(попытку)
    makeOneHit = function(ch,axe) {
        //считаем потраченные мувы
        var move_cost;
        move_cost = .number_range((ch.perm_move / 50) + 1, (ch.perm_move / 20) + 1); //расход мувов на один удар
        if(.buildplot) debug(.fmt("craft_logging: makeOneHit: cost:%d rest_moves:%d ", move_cost, ch.move - move_cost));
        //удар расходует мувы
        if(move_cost <= ch.move) {
            ch.move =  ch.move - move_cost;
        } else {
            ch.act("Ты слишком устал, чтобы рубить деревья.");
            ch.recho("%1$^C1 прекращает рубить дерево.", ch);
            throw "craft_logging: ch not enough moves";
        }

        //считаем нанесенные повреждения
        var damage;
        damage = getOneHitDamage(ch,axe);
        if(isHitSuccess(ch)) {
            //наносим повреждением лесопосадкам
            ch.in_room.logging.trees_health = ch.in_room.logging.trees_health - damage;
            
            //TODO v2 на разную силу повреждения разные сообщения
            if(damage>0)
                ch.act('Ты фигачишь %O5 по дереву!', axe);//TODO заменить фразу
        }
        if(.buildplot) debug(.fmt("craft_logging: makeOneHit: damage:%d rest_trees_health:%d ", damage, ch.in_room.logging.trees_health));
        

        //TODO "отец слышишь рубит?"
    };
    //повреждение от одного удара
    getOneHitDamage = function(ch,axe){
        var demage;
        //TODO v2 учет повреждения оружия
        //TODO v2 учёт DR
        //TOTO v2 усёт силы
        damage = 5;

        if(.buildplot) damage = 20;

        return damage;
    };
    //попал ли удар в дерево
    isHitSuccess = function(ch) {
        //TODO v2 влияние HR, скила, механиков
        return !.chanceOneOf(5);
    };
    logToRoom = function(room) {
        //ch.in_room.echo('...но оно бесследно изчезает!');
        TreeLog.create().obj_to_room(room);
    };

    //получаем количество деревьев в комнате
    getRoomMaxTreesQuantity = function(room) {
        //TODO v2 количество в зависимости от наличия деревьев в окружающих комнатах, плюс рандом
        return 4;
    };
    //количество востанавливаемого деревом hp за раунд 
    getTreeRestoreHp = function(room) {
        //TODO v2 не востанавливать если нет деревьев в соседних клетках
        //TODO v2 влияние на востановление внешних факторов (лужа, огонь...)
        return 1;
    };

    //инициализация комнаты с деревьями
    loggingForestRoomInit = function(room) {
        this = room;
        if(logging!=null) throw('logging: room already inited');

        logging = .Map();

        //TODO рандом?
        logging.max_trees_health = .tmp.craft.logging.getRoomMaxTreesQuantity(room) * .tmp.craft.logging.MaxTreeHP; //количество деревьев * на hp дерева 
        logging.trees_health = logging.max_trees_health;
        logging.sprouts_health = 0; //hp побега - при достижении 100 прибавляется к hp деревьев (если есть)

        //заносим в список свежезаиниченую комнату
        if(!.tmp.craft.logging.LoggingForestList.has(room)) {
            .tmp.craft.logging.LoggingForestList.push_back(room);
        }
        //назначаем комнату главной по обработке списка комнат лесозаготовки
        if(.tmp.craft.logging.LoggingForestList.size()==1) {
            .tmp.craft.logging.makeMainRoom(this);
        }
        //добавляем строчки о сотоянии леса
        onDescr = function(ch, description) {
            return description + .tmp.craft.logging.getAfterLoggingForestDescription(this);
        };
    };

    //генерим описание вырубленного/востаравливающегося леса
    getAfterLoggingForestDescription = function(room) {
        if(room.logging==null) return "";
        
        this = .tmp.craft.logging;
            
        var descr;

        //TODO
        //количество оставшихся деревьев
        var trees_quantity; trees_quantity = getTreesQuantity(room);
        
        //количество срубленных деревьев (пней)
        var stumps_quantity; stumps_quantity = (room.max_trees_health / MaxTreeHP) - trees_quantity;

        //наличие недорубленного дерева
        var chopped_tree; chopped_tree = ((room.trees_health % MaxTreeHP)*100)/MaxTreeHP; //процент недорубленности 

        //процент готовности росткров ((хп_росткров/пни)/максХпДерева)

        //TODO изменить описание после вырубки в зависимости от переменных
        desct="";


        return descr;
    };
/* [Apr 21 22:31:10]:W: fenia fsck:  unreferenced function  cs: 18 (logging) line: 428 (fn:25)
[Apr 21 22:31:10]:W: fenia fsck: 5 unref objects/functions cleared
[Apr 21 22:31:10]:N: [wiznet:ticks] AREA & ROOM TICK!
[Apr 21 22:31:10]:N: >> craft_logging: room.onSpec->Runtime exception Operation not implemented
    in cs #18 (logging) line 275: logging
    called from cs #18 (logging) line 335
    called from RegList::forEach
    called from cs #18 (logging) line 349
    called from <native>
    Ya-ma-ta!

[Apr 21 22:31:10]:N: >> craft_logging: room.onSpec->Runtime exception Operation not implemented
    in cs #18 (logging) line 275: logging
    called from cs #18 (logging) line 335
    called from RegList::forEach
    called from cs #18 (logging) line 349
    called from <native>
    Ya-ma-ta!

[Apr 21 22:31:10]:N: >> craft_logging: room.onSpec->Runtime exception Operation not implemented
    in cs #18 (logging) line 275: logging
    called from cs #18 (logging) line 335
    called from RegList::forEach
    called from cs #18 (logging) line 349
    called from <native>
    Ya-ma-ta!

[Apr 21 22:31:10]:N: >> craft_logging: room.onSpec->Runtime exception Operation not implemented
    in cs #18 (logging) line 275: logging
    called from cs #18 (logging) line 335
    called from RegList::forEach
    called from cs #18 (logging) line 349
    called from <native>
    Ya-ma-ta!

[Apr 21 22:31:10]:N: >> craft_logging: room.onSpec->Runtime exception Operation not implemented
    in cs #18 (logging) line 275: logging
    called from cs #18 (logging) line 335
    called from RegList::forEach
    called from cs #18 (logging) line 349
    called from <native>
    Ya-ma-ta!
*/
    //востановление деревьев. чистка полей комнаты после полного востановления
    loggingRoomsOnSpec = function() {
        //один onSpec на все леса!!!
        .tmp.craft.logging.LoggingForestList.forEach(
            function(){
                try{
                    if(this.logging==null) {
                        //бракованая комната в списке (нет rt поля logging)
                        .tmp.craft.logging.LoggingForestList.sub(this);
                        throw("craft_logging: "+this.vnum+":"+this.name+" -> empty rt logging");
                    }
                    var debug;
                    debug = .tmp.craft.logging.debug;
                    //лес востановлен - чистим
                    if(this.logging.trees_health == logging.max_trees_health) {
                        if(.buildplot) debug(.fmt("craft_logging: room.onSpec: restored %d:%s", this.vnum, this.name));
                        .tmp.craft.logging.loggingForestRoomClean(this);
                        return;
                    }
                    // востановление 400hp по 1hp в раз 4 секунды = 1600 секунд (~26 минут)
                    var restore;
                    restore = .tmp.craft.logging.getTreeRestoreHp(this); 
                    var tree_quantity;
                    //считаем количество уцелевших деревьев
                    tree_quantity = .tmp.craft.logging.getTreesQuantity(this); 

                    if(.buildplot) 
                        debug(.fmt("craft_logging: [%d:%s]start_status: max_hp->%d trees->%d hp->%d sprouts->%d",
                        this.vnum, this.name, this.logging.max_trees_health, tree_quantity, this.logging.trees_health, this.logging.sprouts_health));
                    
                    //если дерево срублено не до конца - востанавливаем его
                    if(tree_quantity > 0 && logging.trees_health % .tmp.craft.logging.MaxTreeHP > 0) {
                        logging.trees_health = logging.trees_health + restore; 
                        if(logging.trees_health / .tmp.craft.logging.MaxTreeHP > tree_quantity) {
                            tree_quantity = .tmp.craft.logging.getTreesQuantity(this);
                            restore = logging.trees_health % .tmp.craft.logging.MaxTreeHP;
                        } else {
                            restore = 0;
                        }
                    }
                    
                    //когда дерево востановлено - ростим побеги
                    if(logging.trees_health < logging.max_trees_health) {
                        logging.sprouts_health = logging.sprouts_health + restore;
                        //если деревья вырублены не все - добавляем каждые .tmp.craft.logging.MaxTreeHP (100) к деревьям
                        if(tree_quantity>0) {
                            if(logging.sprouts_health>=.tmp.craft.logging.MaxTreeHP) {
                                restore = logging.sprouts_health % .tmp.craft.logging.MaxTreeHP;
                                logging.trees_health = logging.trees_health + ((logging.sprouts_health / .tmp.craft.logging.MaxTreeHP) * .tmp.craft.logging.MaxTreeHP);
                                logging.sprouts_health = restore;
                            } 
                        } else { //если все деревья вырублены
                            //если ростков уже выросло как было леса изначально - востаналиваем
                            if(logging.sprouts_health>=logging.max_trees_health) {
                                logging.trees_health = logging.max_trees_health;
                                logging.sprouts_health = 0;
                            }
                        }
                    } 
                    if(.buildplot) 
                    debug(.fmt("craft_logging: [%d:%s]finish_status: max_hp->%d hp->%d sprouts->%d",
                        this.vnum, this.name, this.logging.max_trees_health, this.logging.trees_health, this.logging.sprouts_health));
                }catch(e){
                    .tmp.craft.logging.catchMsg("room.onSpec->"+e);
                }    
            }
        );
    };

    //возвращает количество уцелевших деревьев в комнате
    getTreesQuantity = function(room) {
        var tree_quantity;
        tree_quantity = room.logging.trees_health / .tmp.craft.logging.MaxTreeHP; 
        if(room.logging.trees_health / .tmp.craft.logging.MaxTreeHP > 0) 
            tree_quantity = tree_quantity + 1;
        
        return tree_quantity;
    };

    makeMainRoom = function (room) {
        room.onSpec = function() {.tmp.craft.logging.loggingRoomsOnSpec();};
    };

    //чистим комнату с деревьями
    loggingForestRoomClean = function(room) {
        room.logging = null;
        .tmp.craft.logging.LoggingForestList.sub(room);
        room.onDescr = null;
        if(room.onSpec!=null) {
            room.onSpec = null;
            if(.tmp.craft.logging.LoggingForestList.size()!=0) {
                .tmp.craft.logging.makeMainRoom(.tmp.craft.logging.LoggingForestList.back());
            } else {
                .tmp.craft.logging.debug("craft_logging: all room restored.");
            }
        }
    };

    //проверки, не стоит ли прервать наше увлекательное занятие
    sleepRoom = function(seconds, ch, axe) {
        var room;
        room = ch.in_room;

        var i;
        for(i = 0; i < seconds*4; i = i + 1) {
            .scheduler.sleep(1);

            //помер
            if (ch.dead)
                throw "logging: ch is dead";
            //покинул комнату
            if (room != ch.in_room){
                ch.act("Ты прекращаешь рубить дерево.");
                room.ppl.sub(ch).call.act("%1$^C1 прекращает рубить дерево.", ch);
                throw "logging: ch left the room";
            }
            //больше не стоим (деремся)
            if (!(ch.position&.tables.position_table.stand)) {
                ch.act("Ты не можешь продолжать рубить дерево.");
                ch.recho("%1$^C1 прекращает рубить дерево.", ch);
                throw "logging: ch not standing";
            }
            //передумал
            if(ch.logging==null) {
                ch.act("Ты прекращаешь рубить дерево.");
                ch.recho("%1$^C1 прекращает рубить дерево.", ch);
                throw "logging: second axe use or axe is removed";
            }
            //изчез топор из рук
            if(ch.get_eq_char('wield')!=axe) {
                ch.act("Ты не можешь рубить деревья не вооружившись топором.");
                room.ppl.sub(ch).call.act("%1$^C1 прекращает рубить дерево.", ch);
                throw "logging: axe is lost";
            }
        }
    };
    
    catchMsg = function(e) {
        var ch;
        ch = .get_char_world('Zaleshanin');
        if(ch==null)
            ch = .get_char_world('Miyamoto');

        if(ch!=null)
            ch.ptc('craft_logging: '+e);
        else
            .print('craft_logging: '+e);
    };

    debug = function(str) {
        //if(!.buildplot) return;
        var ch;
        ch = .get_char_world('zaleshanin');
        if(ch==null)
            ch = .get_char_world('miyamoto');

        if(ch!=null) 
            ch.act('debug:%s',str);
    };
})